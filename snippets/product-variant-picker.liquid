<style>
  .variant-picker__radio-input:checked + .variant-picker__label,
  .variant-picker__radio-input:checked + .variant-picker__label--swatch {
    border-color: rgb(var(--color-primary-brand));
    border-width: 2px;
  }

  .variant-picker__label.unavailable {
    text-decoration: line-through;
    opacity: 0.4;
    cursor: not-allowed;
  }
</style>

<variant-picker class="variant-picker-element block mt-24 mb-24 flex flex-col gap-16" data-section-id="{{ section.id }}" data-product-url="{{ product.url | within: collection }}">
  {%- for option in product.options_with_values -%}
    <fieldset class="variant-picker__option-group border-none m-0 p-0 flex flex-col gap-8" role="radiogroup">
      <legend class="variant-picker__option-name fw-500 fs-14-lh-20-ls-0_1 text-primary block">{{ option.name }}</legend>
      <div class="variant-picker__values flex flex-wrap gap-8">
        {%- for value in option.values -%}
          {%- liquid
            assign is_color_option = false
            assign downcased_option_name = option.name | downcase
            if downcased_option_name == 'color' or downcased_option_name == 'colour'
              assign is_color_option = true
              assign color_handle = value | handle
              assign color_swatch_image_file = color_handle | append: '.png'
              assign color_swatch_asset_url = images[color_swatch_image_file] | image_url: width: 44
            endif
          -%}
          <div class="variant-picker__value-wrapper">
            <input
              type="radio"
              id="option-{{ option.position }}-{{ forloop.index }}"
              name="option-{{ option.position }}"
              value="{{ value | escape }}"
              {% if option.selected_value == value %}checked{% endif %}
              class="variant-picker__radio-input h-0 p-0 border-none w-0 opacity-0 pointer-events-none absolute"
            >
            <label
              for="option-{{ option.position }}-{{ forloop.index }}"
              class="variant-picker__label flex items-center justify-center relative cursor-pointer left-0-priority pointer-events-auto fw-500 fs-13-lh-16-ls-0_2-priority border-0 border-solid {% if is_color_option %}variant-picker__label--swatch w-36 h-36 rounded-12{% else %}min-w-64 h-44 border-1 border-color rounded-100 pt-18 pr-16 pb-18 pl-16{% endif %}"
              style="
                {%- if is_color_option -%}
                  {%- if images[color_swatch_image_file] != blank -%}
                    background-image: url({{ color_swatch_asset_url }});
                  {%- else -%}
                    background-color: {{ value.swatch.color }};
                  {%- endif -%}
                {%- endif -%}
              "
            >
              {% if is_color_option == false %}{{ value }}{% endif %}
            </label>
          </div>
        {%- endfor -%}
      </div>
    </fieldset>
  {%- endfor -%}
</variant-picker>

<script>
  class VariantPicker extends HTMLElement {
    constructor() {
      super();
      this.variants = {{ product.variants | json }};
      this.addEventListener('change', this.onVariantChange);
      
      // Use requestAnimationFrame to ensure DOM is fully ready
      requestAnimationFrame(() => {
        this._selectVariantFromUrl();
        this._updateAvailability();
      });
    }

    onVariantChange() {
      const selectedVariant = this.getSelectedVariant();
      if (!selectedVariant) return;

      const browserUrl = `${this.dataset.productUrl}?variant=${selectedVariant.id}`;
      const fetchUrl = `${browserUrl}&section_id=${this.dataset.sectionId}`;

      this.updateURL(browserUrl);
      this.fetchAndUpdateSection(fetchUrl, selectedVariant);
      this._updateLegends(selectedVariant);
      this._updateAvailability();
    }

    _updateAvailability() {
      const currentSelections = Array.from(this.querySelectorAll('.variant-picker__option-group')).map(fieldset => 
        fieldset.querySelector('input:checked')?.value
      );

      this.querySelectorAll('.variant-picker__option-group').forEach((fieldset, optionIndex) => {
        fieldset.querySelectorAll('.variant-picker__value-wrapper').forEach(wrapper => {
          const input = wrapper.querySelector('input');
          const label = wrapper.querySelector('label');
          const value = input.value;

          let tempOptions = [...currentSelections];
          tempOptions[optionIndex] = value;

          const isAvailable = this.variants.some(variant => {
            const matches = variant.options.every((opt, i) => opt === tempOptions[i]);
            return matches && variant.available;
          });

          if (isAvailable) {
            label.classList.remove('unavailable');
            input.disabled = false;
          } else {
            label.classList.add('unavailable');
            input.disabled = true;
          }
        });
      });
    }

    _selectVariantFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      const variantIdFromUrl = urlParams.get('variant');
      
      if (!variantIdFromUrl) {
        // If no variant in URL, just update legends with currently selected variant
        const selectedVariant = this.getSelectedVariant();
        this._updateLegends(selectedVariant);
        
        // Set media to first variant's featured media if available
        if (selectedVariant) {
          this.setActiveMedia(selectedVariant);
        }
        return;
      }

      const targetVariant = this.variants.find(variant => variant.id.toString() === variantIdFromUrl);
      if (!targetVariant) {
        console.warn('Variant not found for ID:', variantIdFromUrl);
        return;
      }

      // Select the radio buttons for this variant
      targetVariant.options.forEach((optionValue, index) => {
        const optionPosition = index + 1;
        const selector = `input[name="option-${optionPosition}"][value="${optionValue}"]`;
        const radioButton = this.querySelector(selector);
        if (radioButton) {
          radioButton.checked = true;
        } else {
          console.warn('Radio button not found for:', selector);
        }
      });

      // Update the media gallery and legends
      this._updateLegends(targetVariant);
      
      // Wait a bit longer for media gallery to be initialized
      setTimeout(() => {
        this.setActiveMedia(targetVariant);
      }, 100);
    }

    _updateLegends(variant) {
      if (!variant) return;
      this.querySelectorAll('.variant-picker__option-group').forEach((fieldset, index) => {
        const legend = fieldset.querySelector('.variant-picker__option-name');
        const optionName = legend.textContent.split(':')[0].trim();
        const selectedValue = variant.options[index];
        legend.textContent = `${optionName}: ${selectedValue}`;
      });
    }

    getSelectedVariant() {
      const selectedOptions = Array.from(this.querySelectorAll('input[type="radio"]:checked')).map(input => input.value);
      return this.variants.find(variant => {
        return variant.options.every((optionValue, index) => {
          return selectedOptions[index] === optionValue;
        });
      });
    }

    updateURL(url) {
      window.history.replaceState({}, '', url);
    }

    fetchAndUpdateSection(url, variant) {
      const productGrid = document.querySelector('.product-grid');
      if (productGrid) productGrid.style.opacity = '0.5';

      fetch(url)
        .then(response => response.text())
        .then(responseText => {
          const newHtml = new DOMParser().parseFromString(responseText, 'text/html');
          
          const newInfo = newHtml.querySelector(`#product-info-${this.dataset.sectionId}`);
          const oldInfo = document.querySelector(`#product-info-${this.dataset.sectionId}`);
          if (newInfo && oldInfo) oldInfo.innerHTML = newInfo.innerHTML;

          const newMedia = newHtml.querySelector(`#product-media-${this.dataset.sectionId}`);
          const oldMedia = document.querySelector(`#product-media-${this.dataset.sectionId}`);
          if (newMedia && oldMedia) oldMedia.innerHTML = newMedia.innerHTML;
          
          this.setActiveMedia(variant);
        })
        .catch(e => console.error('Variant Picker: Error during fetch:', e))
        .finally(() => {
          if (productGrid) productGrid.style.opacity = '1';
        });
    }
    
    setActiveMedia(variant) {
      if (!variant || !variant.featured_media) {
        console.log('No variant or featured media found');
        return;
      }
      
      const featuredMediaId = variant.featured_media.id.toString();
      console.log('Setting active media to:', featuredMediaId);
      
      // Multiple attempts to find and update the media gallery
      const attempts = [
        () => {
          const mediaGalleryElement = document.querySelector('product-media-gallery');
          if (mediaGalleryElement && mediaGalleryElement.setActiveMediaById) {
            return mediaGalleryElement.setActiveMediaById(featuredMediaId);
          }
          return false;
        },
        () => {
          const mediaGallery = document.querySelector(`#product-media-${this.dataset.sectionId}`);
          if (mediaGallery) {
            const galleryElement = mediaGallery.querySelector('product-media-gallery');
            if (galleryElement && galleryElement.setActiveMediaById) {
              return galleryElement.setActiveMediaById(featuredMediaId);
            }
          }
          return false;
        },
        () => {
          // Fallback for direct swiper manipulation
          const swiperContainer = document.querySelector('.product-media-swiper');
          if (swiperContainer) {
            const slides = swiperContainer.querySelectorAll('.swiper-slide');
            let targetIndex = -1;
            
            slides.forEach((slide, index) => {
              if (slide.dataset.mediaId === featuredMediaId) {
                targetIndex = index;
              }
            });
            
            if (targetIndex !== -1 && swiperContainer.swiper) {
              swiperContainer.swiper.slideTo(targetIndex);
              console.log('Used swiper fallback to slide:', targetIndex);
              return true;
            }
          }
          return false;
        }
      ];
      
      // Try each method with delays
      const tryMethod = (methodIndex = 0) => {
        if (methodIndex >= attempts.length) {
          console.log('All media gallery update methods failed');
          return;
        }
        
        try {
          const success = attempts[methodIndex]();
          if (success) {
            console.log(`Media gallery updated using method ${methodIndex + 1}`);
            return;
          }
        } catch (error) {
          console.error(`Method ${methodIndex + 1} failed:`, error);
        }
        
        // Try next method after a short delay
        setTimeout(() => tryMethod(methodIndex + 1), 50);
      };
      
      // Start trying methods immediately and with delays
      tryMethod(0);
      setTimeout(() => tryMethod(0), 100);
      setTimeout(() => tryMethod(0), 250);
    }
  }

  if (!customElements.get('variant-picker')) {
    customElements.define('variant-picker', VariantPicker);
  }
</script>