<style>
  .variant-picker__radio-input:checked + .variant-picker__label,
  .variant-picker__radio-input:checked + .variant-picker__label--swatch {
    border-color: rgb(var(--color-primary-brand));
    border-width: 2px;
  }

  .variant-picker__label.unavailable {
    text-decoration: line-through;
    opacity: 0.4;
    cursor: not-allowed;
  }
</style>

<variant-picker class="variant-picker-element block mt-24 mb-24 flex flex-col gap-16" data-section-id="{{ section.id }}" data-product-url="{{ product.url | within: collection }}">
  {%- for option in product.options_with_values -%}
    <fieldset class="variant-picker__option-group border-none m-0 p-0 flex flex-col gap-8" role="radiogroup">
      <legend class="variant-picker__option-name fw-500 fs-14-lh-20-ls-0_1 text-primary block">{{ option.name }}</legend>
      <div class="variant-picker__values flex flex-wrap gap-8">
        {%- for value in option.values -%}
          {%- liquid
            assign is_color_option = false
            assign downcased_option_name = option.name | downcase
            if downcased_option_name == 'color' or downcased_option_name == 'colour'
              assign is_color_option = true
              assign color_handle = value | handle
              assign color_swatch_image_file = color_handle | append: '.png'
              assign color_swatch_asset_url = images[color_swatch_image_file] | image_url: width: 44
            endif
          -%}
          <div class="variant-picker__value-wrapper">
            <input
              type="radio"
              id="option-{{ option.position }}-{{ forloop.index }}"
              name="option-{{ option.position }}"
              value="{{ value | escape }}"
              {% if option.selected_value == value %}checked{% endif %}
              class="variant-picker__radio-input h-0 p-0 border-none w-0 opacity-0 pointer-events-none absolute"
            >
            <label
              for="option-{{ option.position }}-{{ forloop.index }}"
              class="variant-picker__label flex items-center justify-center relative cursor-pointer left-0-priority pointer-events-auto fw-500 fs-13-lh-16-ls-0_2-priority border-0 border-solid {% if is_color_option %}variant-picker__label--swatch w-36 h-36 rounded-12{% else %}min-w-64 h-44 border-1 border-color rounded-100 pt-18 pr-16 pb-18 pl-16{% endif %}"
              style="
                {%- if is_color_option -%}
                  {%- if images[color_swatch_image_file] != blank -%}
                    background-image: url({{ color_swatch_asset_url }});
                  {%- else -%}
                    background-color: {{ value.swatch.color }};
                  {%- endif -%}
                {%- endif -%}
              "
            >
              {% if is_color_option == false %}{{ value }}{% endif %}
            </label>
          </div>
        {%- endfor -%}
      </div>
    </fieldset>
  {%- endfor -%}
</variant-picker>

<script>
  class VariantPicker extends HTMLElement {
    constructor() {
      super();
      this.variants = {{ product.variants | json }};
      this.addEventListener('change', this.onVariantChange);
      this._selectVariantFromUrl();
      this._updateAvailability();
    }

    onVariantChange() {
      const selectedVariant = this.getSelectedVariant();
      if (!selectedVariant) return;

      const browserUrl = `${this.dataset.productUrl}?variant=${selectedVariant.id}`;
      const fetchUrl = `${browserUrl}&section_id=${this.dataset.sectionId}`;

      this.updateURL(browserUrl);
      this.fetchAndUpdateSection(fetchUrl, selectedVariant);
      this._updateLegends(selectedVariant);
      this._updateAvailability();
    }

    _updateAvailability() {
      const currentSelections = Array.from(this.querySelectorAll('.variant-picker__option-group')).map(fieldset => 
        fieldset.querySelector('input:checked')?.value
      );

      this.querySelectorAll('.variant-picker__option-group').forEach((fieldset, optionIndex) => {
        fieldset.querySelectorAll('.variant-picker__value-wrapper').forEach(wrapper => {
          const input = wrapper.querySelector('input');
          const label = wrapper.querySelector('label');
          const value = input.value;

          let tempOptions = [...currentSelections];
          tempOptions[optionIndex] = value;

          const isAvailable = this.variants.some(variant => {
            const matches = variant.options.every((opt, i) => opt === tempOptions[i]);
            return matches && variant.available;
          });

          if (isAvailable) {
            label.classList.remove('unavailable');
            input.disabled = false;
          } else {
            label.classList.add('unavailable');
            input.disabled = true;
          }
        });
      });
    }

    _selectVariantFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      const variantIdFromUrl = urlParams.get('variant');
      if (!variantIdFromUrl) {
        this._updateLegends(this.getSelectedVariant());
        return;
      };

      const targetVariant = this.variants.find(variant => variant.id.toString() === variantIdFromUrl);
      if (!targetVariant) return;

      targetVariant.options.forEach((optionValue, index) => {
        const optionPosition = index + 1;
        const selector = `input[name="option-${optionPosition}"][value="${optionValue}"]`;
        const radioButton = this.querySelector(selector);
        if (radioButton) radioButton.checked = true;
      });

      this.setActiveMedia(targetVariant);
      this._updateLegends(targetVariant);
    }

    _updateLegends(variant) {
      if (!variant) return;
      this.querySelectorAll('.variant-picker__option-group').forEach((fieldset, index) => {
        const legend = fieldset.querySelector('.variant-picker__option-name');
        const optionName = legend.textContent.split(':')[0].trim();
        const selectedValue = variant.options[index];
        legend.textContent = `${optionName}: ${selectedValue}`;
      });
    }

    getSelectedVariant() {
      const selectedOptions = Array.from(this.querySelectorAll('input[type="radio"]:checked')).map(input => input.value);
      return this.variants.find(variant => {
        return variant.options.every((optionValue, index) => {
          return selectedOptions[index] === optionValue;
        });
      });
    }

    updateURL(url) {
      window.history.replaceState({}, '', url);
    }

    fetchAndUpdateSection(url, variant) {
      const productGrid = document.querySelector('.product-grid');
      if (productGrid) productGrid.style.opacity = '0.5';

      fetch(url)
        .then(response => response.text())
        .then(responseText => {
          const newHtml = new DOMParser().parseFromString(responseText, 'text/html');
          
          const newInfo = newHtml.querySelector(`#product-info-${this.dataset.sectionId}`);
          const oldInfo = document.querySelector(`#product-info-${this.dataset.sectionId}`);
          if (newInfo && oldInfo) oldInfo.innerHTML = newInfo.innerHTML;

          const newMedia = newHtml.querySelector(`#product-media-${this.dataset.sectionId}`);
          const oldMedia = document.querySelector(`#product-media-${this.dataset.sectionId}`);
          if (newMedia && oldMedia) oldMedia.innerHTML = newMedia.innerHTML;
          
          this.setActiveMedia(variant);
        })
        .catch(e => console.error('Variant Picker: Error during fetch:', e))
        .finally(() => {
          if (productGrid) productGrid.style.opacity = '1';
        });
    }
    
    // Replace the setActiveMedia method in your variant picker with this:
setActiveMedia(variant) {
  if (!variant || !variant.featured_media) return;
  
  const featuredMediaId = variant.featured_media.id.toString();
  
  // Try to find the product media gallery element
  const mediaGalleryElement = document.querySelector('product-media-gallery');
  
  if (mediaGalleryElement) {
    // Use the new gallery's method to set active media
    const success = mediaGalleryElement.setActiveMediaById(featuredMediaId);
    if (success) {
      console.log('Successfully changed to variant media:', featuredMediaId);
      return;
    }
  }
  
  // Fallback: try to find gallery by section ID
  const mediaGallery = document.querySelector(`#product-media-${this.dataset.sectionId}`);
  if (!mediaGallery) return;
  
  const galleryElement = mediaGallery.querySelector('product-media-gallery');
  if (galleryElement) {
    const success = galleryElement.setActiveMediaById(featuredMediaId);
    if (success) {
      console.log('Successfully changed to variant media via section:', featuredMediaId);
      return;
    }
  }
  
  // Final fallback for old gallery structure
  console.log('Using fallback method for media change');
  mediaGallery.querySelectorAll('.main-media-item, .swiper-slide').forEach(item => {
    if (item.dataset.mediaId === featuredMediaId) {
      if (item.classList.contains('swiper-slide')) {
        // If it's a swiper slide, we need to trigger slide change
        const swiperContainer = item.closest('.swiper');
        if (swiperContainer && swiperContainer.swiper) {
          const slideIndex = Array.from(item.parentNode.children).indexOf(item);
          swiperContainer.swiper.slideTo(slideIndex);
        }
      } else {
        // Old structure
        item.classList.remove('opacity-0', 'invisible');
        item.classList.add('opacity-1', 'visible');
      }
    } else if (item.classList.contains('main-media-item')) {
      item.classList.remove('opacity-1', 'visible');
      item.classList.add('opacity-0', 'invisible');
    }
  });

  // Update thumbnails
  mediaGallery.querySelectorAll('.media-thumbnail').forEach(thumb => {
    if (thumb.dataset.mediaId === featuredMediaId) {
      thumb.classList.add('border-2', 'border-solid', 'border-brand');
    } else {
      thumb.classList.remove('border-2', 'border-solid', 'border-brand');
    }
  });
}
  }

  if (!customElements.get('variant-picker')) {
    customElements.define('variant-picker', VariantPicker);
  }
</script>